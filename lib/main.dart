import 'package:flutter/material.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:intl/intl.dart';
import 'package:multi_select_flutter/multi_select_flutter.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'firebase_options.dart'; // Generated by FlutterFire CLI

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(ExpenseTrackerApp());
}

class ExpenseTrackerApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Expense Tracker',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: ExpenseHomePage(),
    );
  }
}

// Expense Model
class Expense {
  final int? id;
  final String title;
  final String description;
  final double amount;
  final List<String> categories;
  final DateTime date;
  final String? firestoreId; // Optional: if we want to store Firestore's own ID

  Expense({
    this.id,
    required this.title,
    required this.description,
    required this.amount,
    required this.categories,
    required this.date,
    this.firestoreId,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'amount': amount,
      'categories': categories.join(','),
      'date': date.toIso8601String(),
    };
  }

  factory Expense.fromMap(Map<String, dynamic> map) {
    return Expense(
      id: map['id'],
      title: map['title'],
      description: map['description'],
      amount: map['amount'],
      categories: map['categories'].split(','),
      date: DateTime.parse(map['date']),
    );
  }

  // For Firestore
  Map<String, dynamic> toFirestoreMap() {
    return {
      'title': title,
      'description': description,
      'amount': amount,
      'categories': categories, // Firestore handles List<String>
      'date': Timestamp.fromDate(date), // Use Firestore Timestamp
    };
  }

  factory Expense.fromFirestoreMap(String firestoreDocId, Map<String, dynamic> map) {
    return Expense(
      id: int.tryParse(firestoreDocId), // Assuming Firestore doc ID is the SQLite int ID
      firestoreId: firestoreDocId,
      title: map['title'],
      description: map['description'],
      amount: (map['amount'] as num).toDouble(),
      categories: List<String>.from(map['categories'] ?? []),
      date: (map['date'] as Timestamp).toDate(),
    );
  }
}

// Category Model
class Category {
  final int? id;
  final String name;
  final String displayName;
  final bool isDefault;
  final String? firestoreId;

  Category({
    this.id,
    required this.name,
    required this.displayName,
    this.isDefault = false,
    this.firestoreId,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'displayName': displayName,
      'isDefault': isDefault ? 1 : 0,
    };
  }

  factory Category.fromMap(Map<String, dynamic> map) {
    return Category(
      id: map['id'],
      name: map['name'],
      displayName: map['displayName'],
      isDefault: map['isDefault'] == 1,
    );
  }

  // For Firestore
  Map<String, dynamic> toFirestoreMap() {
    return {
      'name': name,
      'displayName': displayName,
      'isDefault': isDefault,
    };
  }

  factory Category.fromFirestoreMap(String firestoreDocId, Map<String, dynamic> map) {
    return Category(
      id: int.tryParse(firestoreDocId), // Assuming Firestore doc ID is the SQLite int ID
      firestoreId: firestoreDocId,
      name: map['name'],
      displayName: map['displayName'],
      isDefault: map['isDefault'] ?? false,
    );
  }
}

// Database Helper
class DatabaseHelper {
  static final DatabaseHelper _instance = DatabaseHelper._internal();
  factory DatabaseHelper() => _instance;
  DatabaseHelper._internal();

  static Database? _database;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  Future<Database> _initDatabase() async {
    String path = join(await getDatabasesPath(), 'expenses.db');
    return await openDatabase(
      path,
      version: 2,
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> _onCreate(Database db, int version) async {
    await db.execute('''
      CREATE TABLE expenses(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        amount REAL NOT NULL,
        categories TEXT NOT NULL,
        date TEXT NOT NULL
      )
    ''');

    await db.execute('''
      CREATE TABLE categories(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        displayName TEXT NOT NULL,
        isDefault INTEGER NOT NULL DEFAULT 0
      )
    ''');

    // Insert default categories
    await _insertDefaultCategories(db);
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    if (oldVersion < 2) {
      await db.execute('''
        CREATE TABLE categories(
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL UNIQUE,
          displayName TEXT NOT NULL,
          isDefault INTEGER NOT NULL DEFAULT 0
        )
      ''');
      await _insertDefaultCategories(db);
    }
  }

  Future<void> _insertDefaultCategories(Database db) async {
    final defaultCategoriesList = [
      Category(name: 'food', displayName: 'Food & Dining', isDefault: true),
      Category(name: 'transport', displayName: 'Transportation', isDefault: true),
      Category(name: 'metro', displayName: 'Metro', isDefault: true),
      Category(name: 'entertainment', displayName: 'Entertainment', isDefault: true),
      Category(name: 'health', displayName: 'Health & Medical', isDefault: true),
      Category(name: 'office', displayName: 'Office', isDefault: true),
      Category(name: 'home', displayName: 'Home', isDefault: true),
      Category(name: 'travel', displayName: 'Travel', isDefault: true),
      Category(name: 'groceries', displayName: 'Groceries', isDefault: true),
      Category(name: 'lend', displayName: 'Lend', isDefault: true),
      Category(name: 'borrow', displayName: 'Borrow', isDefault: true),
      Category(name: 'chaap', displayName: 'Chaap', isDefault: true),
      Category(name: 'weekend', displayName: 'Weekend', isDefault: true),
      Category(name: 'medicine & doctor', displayName: 'Medicine & Doctor', isDefault: true),
      Category(name: 'e-rikshaw', displayName: 'E-Rickshaw', isDefault: true),
      Category(name: 'burger king', displayName: 'Burger King', isDefault: true),
    ];

    for (Category category in defaultCategoriesList) {
      // Insert into SQLite, ignore if already exists by name (due to UNIQUE constraint)
      try {
        await db.insert('categories', category.toMap(), conflictAlgorithm: ConflictAlgorithm.ignore);
      } catch (e) {
        // This might happen if UNIQUE constraint on 'name' is violated,
        // which conflictAlgorithm.ignore should handle. Logging for debug.
        print("SQLite insert ignore for default category ${category.name}: $e");
      }

      // Fetch from SQLite to get its ID (whether newly inserted or pre-existing)
      List<Map<String, dynamic>> results = await db.query('categories', where: 'name = ?', whereArgs: [category.name], limit: 1);
      if (results.isNotEmpty) {
        Category dbCategory = Category.fromMap(results.first);
        if (dbCategory.id != null) {
          // Sync this category to Firestore using its SQLite ID as Firestore document ID
          try {
            DocumentSnapshot firestoreDoc = await _firestore.collection('categories').doc(dbCategory.id.toString()).get();
            if (!firestoreDoc.exists) {
              await _firestore.collection('categories').doc(dbCategory.id.toString()).set(dbCategory.toFirestoreMap());
              print('Default category ${dbCategory.name} synced to Firestore with ID ${dbCategory.id}');
            }
          } catch (e) {
            print('Error syncing default category ${dbCategory.name} to Firestore: $e');
          }
        }
      }
    }
  }

  // Expense methods
  Future<int> insertExpense(Expense expense) async {
    final db = await database;
    int sqliteId = await db.insert('expenses', expense.toMap());

    if (sqliteId > 0) {
      Expense expenseWithId = Expense(
          id: sqliteId,
          title: expense.title,
          description: expense.description,
          amount: expense.amount,
          categories: expense.categories,
          date: expense.date);
      try {
        await _firestore
            .collection('expenses')
            .doc(sqliteId.toString())
            .set(expenseWithId.toFirestoreMap());
      } catch (e) {
        print('Error inserting expense to Firestore: $e');
        // Optionally, implement a retry mechanism or mark for later sync
      }
    }
    return sqliteId;
  }

  Future<List<Expense>> getAllExpenses() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query('expenses', orderBy: 'date DESC');
    return List.generate(maps.length, (i) => Expense.fromMap(maps[i]));
  }

  Future<int> updateExpense(Expense expense) async {
    final db = await database;
    if (expense.id == null) return 0; // Cannot update expense without ID

    int count = await db.update(
      'expenses',
      expense.toMap(),
      where: 'id = ?',
      whereArgs: [expense.id],
    );

    if (count > 0) {
      try {
        await _firestore
            .collection('expenses')
            .doc(expense.id.toString())
            .update(expense.toFirestoreMap());
      } catch (e) {
        print('Error updating expense in Firestore: $e');
      }
    }
    return count;
  }

  Future<int> deleteExpense(int id) async {
    final db = await database;
    int count = await db.delete('expenses', where: 'id = ?', whereArgs: [id]);
    if (count > 0) {
      try {
        await _firestore.collection('expenses').doc(id.toString()).delete();
      } catch (e) {
        print('Error deleting expense from Firestore: $e');
      }
    }
    return count;
  }

  // Category methods
  Future<int> insertCategory(Category category) async {
    final db = await database;
    int sqliteId = await db.insert('categories', category.toMap(), conflictAlgorithm: ConflictAlgorithm.fail);

    if (sqliteId > 0) {
      Category categoryWithId = Category(
          id: sqliteId,
          name: category.name,
          displayName: category.displayName,
          isDefault: category.isDefault);
      try {
        await _firestore
            .collection('categories')
            .doc(sqliteId.toString())
            .set(categoryWithId.toFirestoreMap());
      } catch (e) {
        print('Error inserting category to Firestore: $e');
      }
    }
    return sqliteId;
  }

  Future<List<Category>> getAllCategories() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query('categories', orderBy: 'displayName ASC');
    return List.generate(maps.length, (i) => Category.fromMap(maps[i]));
  }

  Future<int> deleteCategory(int id) async {
    final db = await database;

    List<Map<String, dynamic>> results = await db.query('categories', where: 'id = ?', whereArgs: [id]);
    if (results.isEmpty) return 0;

    Category categoryToDelete = Category.fromMap(results.first);
    if (categoryToDelete.isDefault) {
      print("Cannot delete a default category.");
      return 0; 
    }

    int count = await db.delete('categories', where: 'id = ? AND isDefault = 0', whereArgs: [id]);
    if (count > 0) {
      try {
        await _firestore.collection('categories').doc(id.toString()).delete();
      } catch (e) {
        print('Error deleting category from Firestore: $e');
      }
    }
    return count;
  }

  Future<bool> categoryExists(String name) async {
    final db = await database;
    final result = await db.query('categories', where: 'name = ?', whereArgs: [name]);
    return result.isNotEmpty;
  }

  // Sync methods from Firestore to SQLite
  Future<void> syncExpensesFromFirestore() async {
    final db = await database;
    try {
      QuerySnapshot snapshot = await _firestore.collection('expenses').get();
      for (var doc in snapshot.docs) {
        Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
        Expense expense = Expense.fromFirestoreMap(doc.id, data);
        // Using replace to insert if new, or update if exists (based on primary key 'id')
        await db.insert('expenses', expense.toMap(), conflictAlgorithm: ConflictAlgorithm.replace);
      }
      print("Expenses synced from Firestore");
    } catch (e) {
      print("Error syncing expenses from Firestore: $e");
    }
  }
  
  Future<void> syncCategoriesFromFirestore() async {
    final db = await database;
    try {
      QuerySnapshot snapshot = await _firestore.collection('categories').get();
      for (var doc in snapshot.docs) {
          Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
          Category category = Category.fromFirestoreMap(doc.id, data);
          // Using replace to insert if new, or update if exists (based on primary key 'id')
          // This also correctly handles default categories if their IDs match.
          await db.insert('categories', category.toMap(), conflictAlgorithm: ConflictAlgorithm.replace);
      }
      print("Categories synced from Firestore");
    } catch (e) {
      print("Error syncing categories from Firestore: $e");
    }
  }
}

// Main Home Page
class ExpenseHomePage extends StatefulWidget {
  @override
  _ExpenseHomePageState createState() => _ExpenseHomePageState();
}

class _ExpenseHomePageState extends State<ExpenseHomePage> {

  final DatabaseHelper _databaseHelper = DatabaseHelper();
  List<Expense> _expenses = [];
  List<Expense> _filteredExpenses = [];
  List<Category> _categories = [];
  BuildContext? _context;

  // Filter variables
  List<String> _selectedFilterCategories = [];
  DateTime? _startDate;
  DateTime? _endDate;

  // Helper for responsive font size
  double rFS(double fontSize) {
    final screenWidth = MediaQuery.of(_context!).size.width;
    // Adjust baseScreenWidth to your design's reference width (e.g., iPhone X, Pixel 5)
    const baseScreenWidth = 450.0; 
    final scale = screenWidth / baseScreenWidth;
    // Clamp scale to avoid excessively large/small fonts, adjust clamps as needed
    return (fontSize * scale).clamp(fontSize * 0.5, fontSize * 1); 
  }

  // Helper for responsive spacing (padding, margin, icon size, etc.)
  double rSP(double space) {
    final screenWidth = MediaQuery.of(_context!).size.width;
    const baseScreenWidth = 375.0;
    final scale = screenWidth / baseScreenWidth;
    return (space * scale).clamp(space * 0.85, space * 1.3);
  }

  // Calculate total expense
  double get totalExpense {
    return _filteredExpenses.fold(0.0, (sum, expense) => sum + expense.amount);
  }

  @override
  void initState() {
    super.initState();
    _syncAndLoadAllData(); // Renamed and consolidated data loading
  }

  Future<void> _loadCategoriesFromDb() async {
    final categories = await _databaseHelper.getAllCategories();
    if (mounted) {
      setState(() {
        _categories = categories;
      });
    }
  }

  Future<void> _loadExpensesFromDb() async {
    final expenses = await _databaseHelper.getAllExpenses();
    if (mounted) {
      setState(() {
        _expenses = expenses;
        // Apply filters with the newly loaded/synced expenses
        // If _applyFilters is not called here, ensure _filteredExpenses is initialized
        // The original _applyFilters logic will use the updated _expenses list.
        _applyFilters(); 
      });
    }
  }

  void _applyFilters() {
    setState(() {
      _filteredExpenses = _expenses.where((expense) {
        // Category filter
        bool categoryMatch = _selectedFilterCategories.isEmpty ||
            _selectedFilterCategories.any((category) => expense.categories.contains(category));

        // Date range filter
        bool dateMatch = true;
        if (_startDate != null) {
          dateMatch = dateMatch && expense.date.isAfter(_startDate!.subtract(Duration(days: 1)));
        }
        if (_endDate != null) {
          dateMatch = dateMatch && expense.date.isBefore(_endDate!.add(Duration(days: 1)));
        }

        return categoryMatch && dateMatch;
      }).toList();
    });
  }

  void _clearFilters() {
    setState(() {
      _selectedFilterCategories = [];
      _startDate = null;
      _endDate = null;
      _filteredExpenses = _expenses;
    });
  }

  @override
  Widget build(BuildContext context) {
    _context = context;
    return Scaffold(
      backgroundColor: Colors.grey.shade50,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: Colors.white,
        title: Text('Expense Tracker', 
          style: TextStyle(color: Colors.black87, fontWeight: FontWeight.bold)),
        actions: [
          Container(
            margin: EdgeInsets.only(right: 8),
            child: IconButton(
              icon: Icon(Icons.category, color: Colors.green.shade600, size: rSP(24)),
              onPressed: () => _showCategoriesDialog(context),
              style: IconButton.styleFrom(
                backgroundColor: Colors.green.shade50,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              ),
            ),
          ),
          Container(
            margin: EdgeInsets.only(right: 8),
            child: IconButton(
              icon: Icon(Icons.tune, color: Colors.blue.shade600, size: rSP(24)),
              onPressed: () => _showFilterDialog(context),
              style: IconButton.styleFrom(
                backgroundColor: Colors.blue.shade50,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          // Total Expense Card
          Container(
            margin: EdgeInsets.all(rSP(16)),
            child: Card(
              elevation: rSP(4),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(16))),
              child: Container(
                padding: EdgeInsets.all(rSP(20)),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(rSP(16)),
                  gradient: LinearGradient(
                    colors: [Colors.blue.shade600, Colors.blue.shade400],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Total Expenses', 
                          style: TextStyle(color: Colors.white70, fontSize: rFS(16))),
                        SizedBox(height: rSP(4)),
                        Text('₹${totalExpense.toStringAsFixed(2)}', 
                          style: TextStyle(color: Colors.white, fontSize: rFS(28), fontWeight: FontWeight.bold)),
                      ],
                    ),
                    Container(
                      padding: EdgeInsets.all(rSP(12)),
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(rSP(12)),
                      ),
                      child: Icon(Icons.account_balance_wallet, 
                        color: Colors.white, size: rSP(32)),
                    ),
                  ],
                ),
              ),
            ),
          ),

          // Filter Summary
          if (_selectedFilterCategories.isNotEmpty || _startDate != null || _endDate != null)
            Container(
              margin: EdgeInsets.symmetric(horizontal: rSP(16)),
              padding: EdgeInsets.all(rSP(16)),
              decoration: BoxDecoration(
                color: Colors.orange.shade50,
                borderRadius: BorderRadius.circular(rSP(12)),
                border: Border.all(color: Colors.orange.shade200),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Row(
                        children: [
                          Icon(Icons.filter_alt, color: Colors.orange.shade600, size: rSP(20)),
                          SizedBox(width: rSP(8)),
                          Text('Active Filters', 
                            style: TextStyle(fontWeight: FontWeight.bold, color: Colors.orange.shade800, fontSize: rFS(14))),
                        ],
                      ),
                      TextButton.icon(
                        onPressed: _clearFilters,
                        icon: Icon(Icons.clear, size: rSP(16)),
                        label: Text('Clear', style: TextStyle(fontSize: rFS(13))),
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.orange.shade600,
                          padding: EdgeInsets.symmetric(horizontal: rSP(12), vertical: rSP(4)),
                        ),
                      ),
                    ],
                  ),
                  if (_selectedFilterCategories.isNotEmpty) ...[
                    SizedBox(height: rSP(8)),
                    Wrap(
                      spacing: rSP(6),
                      runSpacing: rSP(4),
                      children: _selectedFilterCategories.map((category) => Chip(
                        label: Text(category, style: TextStyle(fontSize: rFS(12))),
                        backgroundColor: Colors.orange.shade100,
                        deleteIcon: Icon(Icons.close, size: rSP(16)),
                        onDeleted: () {
                          setState(() {
                            _selectedFilterCategories.remove(category);
                          });
                          _applyFilters();
                        },
                      )).toList(), // Chip's internal padding might also need adjustment if possible
                    ),
                  ],
                  if (_startDate != null || _endDate != null) ...[
                    SizedBox(height: 8),
                    Container(
                      padding: EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: Colors.orange.shade100, // Chip's internal padding might also need adjustment if possible
                        borderRadius: BorderRadius.circular(rSP(8)),
                      ),
                      child: Text(
                        '${_startDate != null ? DateFormat('MMM dd, yyyy').format(_startDate!) : 'Start'} - ${_endDate != null ? DateFormat('MMM dd, yyyy').format(_endDate!) : 'End'}',
                        style: TextStyle(fontSize: rFS(12), color: Colors.orange.shade800),
                      ),
                    ),
                  ],
                ],
              ),
            ),
          
          SizedBox(height: rSP(16)),
          
          // Expense List
          Expanded(
            child: _filteredExpenses.isEmpty
                ? Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Container(
                          padding: EdgeInsets.all(rSP(24)),
                          decoration: BoxDecoration(
                            color: Colors.grey.shade100,
                            shape: BoxShape.circle,
                          ),
                          child: Icon(Icons.receipt_long, size: rSP(48), color: Colors.grey.shade400),
                        ),
                        SizedBox(height: rSP(16)),
                        Text('No expenses found', 
                          style: TextStyle(fontSize: rFS(18), color: Colors.grey.shade600, fontWeight: FontWeight.w500)),
                        SizedBox(height: rSP(8)),
                        Text('Tap the + button to add your first expense', 
                          style: TextStyle(fontSize: rFS(14), color: Colors.grey.shade500)),
                      ],
                    ),
                  )
                : ListView.builder(
                    padding: EdgeInsets.symmetric(horizontal: 16),
                    itemCount: _filteredExpenses.length,
                    itemBuilder: (context, index) {
                      final expense = _filteredExpenses[index];
                      return Container(
                        margin: EdgeInsets.only(bottom: rSP(12)),
                        child: Card(
                          elevation: rSP(2),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(16))),
                          child: Padding(
                            padding: EdgeInsets.all(rSP(16)),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Row(
                                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                  children: [
                                    Expanded(
                                      child: Text(expense.title, 
                                        style: TextStyle(fontWeight: FontWeight.bold, fontSize: rFS(16))),
                                    ),
                                    Row(
                                      children: [
                                        Text('₹${expense.amount.toStringAsFixed(2)}', 
                                          style: TextStyle(
                                            fontWeight: FontWeight.bold, 
                                            fontSize: rFS(18),
                                            color: Colors.green.shade600,
                                          )),
                                        SizedBox(width: rSP(8)),
                                        IconButton(
                                          icon: Icon(Icons.delete_outline, color: Colors.red.shade400, size: rSP(22)),
                                          onPressed: () => _deleteExpense(expense.id!, context),
                                          style: IconButton.styleFrom(
                                            backgroundColor: Colors.red.shade50,
                                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(8))),
                                            padding: EdgeInsets.all(rSP(8)),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ],
                                ),
                                SizedBox(height: rSP(8)),
                                Text(expense.description, 
                                  style: TextStyle(color: Colors.grey.shade600, fontSize: rFS(14))),
                                SizedBox(height: rSP(12)),
                                Row(
                                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                  children: [
                                    Expanded(
                                      child: Wrap(
                                        spacing: rSP(6),
                                        runSpacing: rSP(4),
                                        children: expense.categories.map((categoryName) {
                                          final category = _categories.firstWhere(
                                            (c) => c.name == categoryName,
                                            orElse: () => Category(name: categoryName, displayName: categoryName),
                                          );
                                          return Container(
                                            padding: EdgeInsets.symmetric(horizontal: rSP(8), vertical: rSP(4)),
                                            decoration: BoxDecoration(
                                              color: Colors.blue.shade50,
                                              borderRadius: BorderRadius.circular(rSP(8)),
                                              border: Border.all(color: Colors.blue.shade200),
                                            ),
                                            child: Text(category.displayName, 
                                              style: TextStyle(fontSize: rFS(12), color: Colors.blue.shade700)),
                                          );
                                        }).toList(),
                                      ),
                                    ),
                                    Container(
                                      padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                      decoration: BoxDecoration(
                                        color: Colors.grey.shade100, // padding: EdgeInsets.symmetric(horizontal: rSP(8), vertical: rSP(4)),
                                        borderRadius: BorderRadius.circular(rSP(6)),
                                      ),
                                      child: Text(DateFormat('MMM dd, yyyy').format(expense.date), 
                                        style: TextStyle(color: Colors.grey.shade600, fontSize: rFS(12))),
                                    ),
                                  ],
                                ),
                              ],
                            ),
                          ),
                        ),
                      );
                    },
                  ),
          ),
        ],
      ),
      floatingActionButton: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(rSP(16)),
          boxShadow: [
            BoxShadow(
              color: Colors.blue.shade300.withOpacity(0.4),
              blurRadius: rSP(12),
              offset: Offset(0, rSP(6)),
            ),
          ],
        ),
        child: FloatingActionButton.extended(
          onPressed: () => _showAddExpenseDialog(context),
          backgroundColor: Colors.blue.shade600,
          icon: Icon(Icons.add, color: Colors.white, size: rSP(24)),
          label: Text('Add Expense', style: TextStyle(color: Colors.white, fontWeight: FontWeight.w600, fontSize: rFS(16))),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(16))),
        ),
      ),
    );
  }

  void _showCategoriesDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return Dialog(
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(20))),
              child: Container(
                padding: EdgeInsets.all(rSP(24)),
                constraints: BoxConstraints(maxHeight: MediaQuery.of(context).size.height * 0.7),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Row(
                          children: [
                            Container(
                              padding: EdgeInsets.all(rSP(8)),
                              decoration: BoxDecoration(
                                color: Colors.green.shade50,
                                borderRadius: BorderRadius.circular(rSP(8)),
                              ),
                              child: Icon(Icons.category, color: Colors.green.shade600, size: rSP(24)),
                            ),
                            SizedBox(width: rSP(12)),
                            Text('Manage Categories', 
                              style: TextStyle(fontSize: rFS(20), fontWeight: FontWeight.bold)),
                          ],
                        ),
                        IconButton(
                          onPressed: () => _showAddCategoryDialog(context, setState),
                          icon: Icon(Icons.add_circle, color: Colors.green.shade600, size: rSP(28)),
                          style: IconButton.styleFrom(
                            backgroundColor: Colors.green.shade50,
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(8))),
                          ),
                        ),
                      ],
                    ),
                    SizedBox(height: rSP(16)),
                    Expanded(
                      child: ListView.builder(
                        itemCount: _categories.length,
                        itemBuilder: (context, index) {
                          final category = _categories[index];
                          return Card(
                            elevation: rSP(1),
                            margin: EdgeInsets.only(bottom: rSP(8)),
                            child: ListTile(
                              leading: Container(
                                padding: EdgeInsets.all(8),
                                decoration: BoxDecoration(
                                  color: category.isDefault ? Colors.blue.shade50 : Colors.purple.shade50,
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                child: Icon(
                                  category.isDefault ? Icons.star : Icons.label,
                                  color: category.isDefault ? Colors.blue.shade600 : Colors.purple.shade600,
                                  size: rSP(20),
                                ),
                              ),
                              title: Text(category.displayName, 
                                style: TextStyle(fontWeight: FontWeight.w500, fontSize: rFS(15))),
                              subtitle: Text(category.name, 
                                style: TextStyle(color: Colors.grey.shade600, fontSize: rFS(12))),
                              trailing: !category.isDefault
                                  ? IconButton(
                                      icon: Icon(Icons.delete_outline, color: Colors.red.shade400, size: rSP(22)),
                                      onPressed: () => _deleteCategory(category.id!, setState,context),
                                    )
                                  : Container(
                                      padding: EdgeInsets.symmetric(horizontal: rSP(8), vertical: rSP(4)),
                                      decoration: BoxDecoration(
                                        color: Colors.blue.shade50,
                                        borderRadius: BorderRadius.circular(rSP(4)),
                                      ),
                                      child: Text('Default', 
                                        style: TextStyle(
                                          fontSize: rFS(10), 
                                          color: Colors.blue.shade600,
                                          fontWeight: FontWeight.w500,
                                        )),
                                    ),
                            ),
                          );
                        },
                      ),
                    ),
                    SizedBox(height: rSP(16)),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: () => Navigator.pop(context),
                        child: Text('Close', style: TextStyle(color: Colors.white, fontSize: rFS(16))),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.green.shade600,
                          padding: EdgeInsets.all(rSP(16)),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(12))),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }

  void _showAddCategoryDialog(BuildContext context, StateSetter parentSetState) {
    final _formKey = GlobalKey<FormState>();
    final nameController = TextEditingController();
    final displayNameController = TextEditingController();

    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog( // Consider making AlertDialog title and content text responsive too
          title: Text('Add New Category', style: TextStyle(fontSize: rFS(18))),
          content: Form(
            key: _formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextFormField(
                  controller: displayNameController,
                  decoration: InputDecoration(
                    labelText: 'Category Name *',
                    hintText: 'e.g., Groceries',
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(rSP(8))),
                    labelStyle: TextStyle(fontSize: rFS(14)), hintStyle: TextStyle(fontSize: rFS(14)),
                  ),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Category name is required';
                    }
                    return null;
                  },
                  onChanged: (value) {
                    // Auto-generate internal name from display name
                    nameController.text = value.toLowerCase().replaceAll(' ', '_').replaceAll(RegExp(r'[^a-z0-9_]'), '');
                  },
                ),
                SizedBox(height: rSP(16)),
                TextFormField(
                  controller: nameController,
                  decoration: InputDecoration(
                    labelText: 'Internal Name *',
                    hintText: 'e.g., groceries',
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(rSP(8))),
                    helperText: 'Auto-generated, but you can modify',
                    labelStyle: TextStyle(fontSize: rFS(14)), hintStyle: TextStyle(fontSize: rFS(14)), helperStyle: TextStyle(fontSize: rFS(12)),
                  ),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Internal name is required';
                    }
                    if (!RegExp(r'^[a-z0-9_]+$').hasMatch(value)) {
                      return 'Only lowercase letters, numbers, and underscores allowed';
                    }
                    return null;
                  },
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text('Cancel', style: TextStyle(fontSize: rFS(14))),
            ),
            ElevatedButton(
              onPressed: () async {
                if (_formKey.currentState!.validate()) {
                  final name = nameController.text.trim();
                  final displayName = displayNameController.text.trim();
                  
                  // Check if category already exists
                  if (await _databaseHelper.categoryExists(name)) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('Category already exists!', style: TextStyle(fontSize: rFS(14))),
                        backgroundColor: Colors.red,
                      ),
                    );
                    return;
                  }
                  
                  final category = Category(
                    name: name,
                    displayName: displayName,
                    isDefault: false,
                  );
                  
                  await _databaseHelper.insertCategory(category);
                  await _syncAndLoadAllData(); // Refresh all data
                  parentSetState(() {});
                  Navigator.pop(context);
                  
                  ScaffoldMessenger.of(this.context).showSnackBar(
                    SnackBar(
                      content: Text('Category added successfully!', style: TextStyle(fontSize: rFS(14))),
                      backgroundColor: Colors.green,
                    ),
                  );
                }
              },
              child: Text('Add', style: TextStyle(fontSize: rFS(14))),
            ),
          ],
        );
      },
    );
  }

  Future<void> _deleteCategory(int id, StateSetter parentSetState, BuildContext context) async {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Delete Category', style: TextStyle(fontSize: rFS(18))),
          content: Text('Are you sure you want to delete this category? This action cannot be undone.', style: TextStyle(fontSize: rFS(14))),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text('Cancel', style: TextStyle(fontSize: rFS(14))),
            ),
            TextButton(
              onPressed: () async {
                await _databaseHelper.deleteCategory(id);
                await _syncAndLoadAllData(); // Refresh all data
                parentSetState(() {});
                Navigator.pop(context);
                ScaffoldMessenger.of(this.context).showSnackBar(
                  SnackBar(
                    content: Text('Category deleted successfully!', style: TextStyle(fontSize: rFS(14))),
                    backgroundColor: Colors.green,
                  ),
                );
              },
              child: Text('Delete', style: TextStyle(color: Colors.red, fontSize: rFS(14))),
            ),
          ],
        );
      },
    );
  }

  void _showFilterDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        List<String> tempSelectedCategories = List.from(_selectedFilterCategories);
        DateTime? tempStartDate = _startDate;
        DateTime? tempEndDate = _endDate;

        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              title: Text('Filter Expenses', style: TextStyle(fontSize: rFS(18))),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Categories:', style: TextStyle(fontWeight: FontWeight.bold, fontSize: rFS(16))),
                    SizedBox(height: rSP(8)),
                   // Continuation of _showFilterDialog method
                    MultiSelectDialogField<String>(
                      items: _categories.map((category) => MultiSelectItem<String>(category.name, category.displayName)).toList(),
                      title: Text("Select Categories", style: TextStyle(fontSize: rFS(16))),
                      selectedColor: Colors.blue,
                      decoration: BoxDecoration(
                        color: Colors.blue.withAlpha(10),
                        borderRadius: BorderRadius.all(Radius.circular(rSP(8))),
                        border: Border.all(color: Colors.blue, width: 2),
                      ),
                      buttonIcon: Icon(Icons.category, color: Colors.blue, size: rSP(22)),
                      buttonText: Text("Select Categories", style: TextStyle(color: Colors.blue[800], fontSize: rFS(16))),
                      initialValue: tempSelectedCategories,
                      onConfirm: (results) {
                        setState(() {
                          tempSelectedCategories = results;
                        });
                      },
                      itemsTextStyle: TextStyle(fontSize: rFS(14)),      // Style for items in the dialog
                      selectedItemsTextStyle: TextStyle(fontSize: rFS(14), color: Colors.blue), // Style for selected items in the dialog
                      chipDisplay: MultiSelectChipDisplay(
                        textStyle: TextStyle(fontSize: rFS(12), color: Colors.white), // Style for chips displayed after selection
                        chipColor: Colors.blue.shade300,
                        icon: Icon(Icons.close, color: Colors.white, size: rSP(14)),
                      ),
                    ),
                    SizedBox(height: rSP(16)),
                    Text('Date Range:', style: TextStyle(fontWeight: FontWeight.bold, fontSize: rFS(16))),
                    SizedBox(height: rSP(8)),
                    Row(
                      children: [
                        Expanded(
                          child: TextButton.icon(
                            onPressed: () async {
                              final date = await showDatePicker(
                                context: context,
                                initialDate: tempStartDate ?? DateTime.now(),
                                firstDate: DateTime(2020),
                                lastDate: DateTime.now(),
                              );
                              if (date != null) {
                                setState(() {
                                  tempStartDate = date;
                                });
                              }
                            },
                            icon: Icon(Icons.calendar_today, size: rSP(20)),
                            label: Text(tempStartDate != null 
                              ? DateFormat('MMM dd, yyyy').format(tempStartDate!)
                              : 'Start Date', style: TextStyle(fontSize: rFS(14))),
                            style: TextButton.styleFrom(
                              backgroundColor: Colors.grey.shade100,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(8))),
                              padding: EdgeInsets.all(rSP(12)),
                            ),
                          ),
                        ),
                        SizedBox(width: rSP(8)),
                        Expanded(
                          child: TextButton.icon(
                            onPressed: () async {
                              final date = await showDatePicker(
                                context: context,
                                initialDate: tempEndDate ?? DateTime.now(),
                                firstDate: DateTime(2020),
                                lastDate: DateTime.now(),
                              );
                              if (date != null) {
                                setState(() {
                                  tempEndDate = date;
                                });
                              }
                            },
                            icon: Icon(Icons.calendar_today, size: rSP(20)),
                            label: Text(tempEndDate != null 
                              ? DateFormat('MMM dd, yyyy').format(tempEndDate!)
                              : 'End Date', style: TextStyle(fontSize: rFS(14))),
                            style: TextButton.styleFrom(
                              backgroundColor: Colors.grey.shade100,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(8))),
                              padding: EdgeInsets.all(rSP(12)),
                            ),
                          ),
                        ),
                      ],
                    ),
                    if (tempStartDate != null || tempEndDate != null) ...[
                      SizedBox(height: rSP(8)),
                      Row(
                        children: [
                          if (tempStartDate != null)
                            TextButton.icon(
                              onPressed: () {
                                setState(() {
                                  tempStartDate = null;
                                });
                              },
                              icon: Icon(Icons.clear, size: rSP(16)),
                              label: Text('Clear Start', style: TextStyle(fontSize: rFS(12))),
                              style: TextButton.styleFrom(
                                foregroundColor: Colors.red,
                                padding: EdgeInsets.symmetric(horizontal: rSP(8), vertical: rSP(4)),
                              ),
                            ),
                          if (tempEndDate != null)
                            TextButton.icon(
                              onPressed: () {
                                setState(() {
                                  tempEndDate = null;
                                });
                              },
                              icon: Icon(Icons.clear, size: rSP(16)),
                              label: Text('Clear End', style: TextStyle(fontSize: rFS(12))),
                              style: TextButton.styleFrom(
                                foregroundColor: Colors.red,
                                padding: EdgeInsets.symmetric(horizontal: rSP(8), vertical: rSP(4)),
                              ),
                            ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () {
                    // Clear all filters
                    setState(() {
                      tempSelectedCategories = [];
                      tempStartDate = null;
                      tempEndDate = null;
                    });
                  },
                  child: Text('Clear All', style: TextStyle(fontSize: rFS(14))),
                  style: TextButton.styleFrom(foregroundColor: Colors.orange),
                ),
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: Text('Cancel', style: TextStyle(fontSize: rFS(14))),
                ),
                ElevatedButton(
                  onPressed: () {
                    this.setState(() {
                      _selectedFilterCategories = tempSelectedCategories;
                      _startDate = tempStartDate;
                      _endDate = tempEndDate;
                    });
                    _applyFilters();
                    Navigator.pop(context);
                  },
                  child: Text('Apply Filters', style: TextStyle(fontSize: rFS(14))),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.blue.shade600,
                    foregroundColor: Colors.white,
                  ),
                ),
              ],
            );
          },
        );
      },
    );
  }

  void _showAddExpenseDialog(BuildContext context) {
    final _formKey = GlobalKey<FormState>();
    final titleController = TextEditingController();
    final descriptionController = TextEditingController();
    final amountController = TextEditingController();
    List<String> selectedCategories = [];
    DateTime selectedDate = DateTime.now();

    showDialog(
      context: context,
      builder: (BuildContext context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return Dialog(
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(20))),
              child: Container(
                padding: EdgeInsets.all(rSP(24)),
                constraints: BoxConstraints(maxHeight: MediaQuery.of(context).size.height * 0.8),
                child: Form(
                  key: _formKey,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Container(
                            padding: EdgeInsets.all(rSP(8)),
                            decoration: BoxDecoration(
                              color: Colors.blue.shade50,
                              borderRadius: BorderRadius.circular(rSP(8)),
                            ),
                            child: Icon(Icons.add_circle, color: Colors.blue.shade600, size: rSP(24)),
                          ),
                          SizedBox(width: rSP(12)),
                          Text('Add New Expense', 
                            style: TextStyle(fontSize: rFS(20), fontWeight: FontWeight.bold)),
                        ],
                      ),
                      SizedBox(height: rSP(20)),
                      Expanded(
                        child: SingleChildScrollView(
                          child: Column(
                            children: [
                              TextFormField(
                                controller: titleController,
                                decoration: InputDecoration(
                                  labelText: 'Title *',
                                  hintText: 'Enter expense title',
                                  prefixIcon: Icon(Icons.title, size: rSP(20)),
                                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(rSP(12))),
                                  filled: true,
                                  fillColor: Colors.grey.shade50,
                                  labelStyle: TextStyle(fontSize: rFS(14)), hintStyle: TextStyle(fontSize: rFS(14)),
                                ),
                                validator: (value) {
                                  if (value == null || value.trim().isEmpty) {
                                    return 'Title is required';
                                  }
                                  return null;
                                },
                              ),
                              SizedBox(height: rSP(16)),
                              TextFormField(
                                controller: descriptionController,
                                decoration: InputDecoration(
                                  labelText: 'Description',
                                  hintText: 'Enter expense description',
                                  prefixIcon: Icon(Icons.description, size: rSP(20)),
                                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(rSP(12))),
                                  filled: true,
                                  fillColor: Colors.grey.shade50,
                                  labelStyle: TextStyle(fontSize: rFS(14)), hintStyle: TextStyle(fontSize: rFS(14)),
                                ),
                                maxLines: 2,
                              ),
                              SizedBox(height: rSP(16)),
                              TextFormField(
                                controller: amountController,
                                decoration: InputDecoration(
                                  labelText: 'Amount *',
                                  hintText: 'Enter amount',
                                  prefixIcon: Icon(Icons.currency_rupee),
                                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                                  filled: true, // prefixIcon: Icon(Icons.currency_rupee, size: rSP(20)),
                                  fillColor: Colors.grey.shade50,
                                  labelStyle: TextStyle(fontSize: rFS(14)), hintStyle: TextStyle(fontSize: rFS(14)),
                                ),
                                keyboardType: TextInputType.numberWithOptions(decimal: true),
                                validator: (value) {
                                  if (value == null || value.trim().isEmpty) {
                                    return 'Amount is required';
                                  }
                                  if (double.tryParse(value) == null) {
                                    return 'Please enter a valid amount';
                                  }
                                  if (double.parse(value) <= 0) {
                                    return 'Amount must be greater than 0';
                                  }
                                  return null;
                                },
                              ),
                              SizedBox(height: rSP(16)),
                              MultiSelectDialogField<String>(
                                items: _categories.map((category) => 
                                  MultiSelectItem<String>(category.name, category.displayName)).toList(),
                                title: Text("Select Categories", style: TextStyle(fontSize: rFS(16))),
                                selectedColor: Colors.blue,
                                decoration: BoxDecoration(
                                  color: Colors.blue.withAlpha(10),
                                  borderRadius: BorderRadius.all(Radius.circular(rSP(12))),
                                  border: Border.all(color: Colors.blue, width: 2),
                                ),
                                buttonIcon: Icon(Icons.category, color: Colors.blue, size: rSP(22)),
                                buttonText: Text("Select Categories *", 
                                  style: TextStyle(color: Colors.blue[800], fontSize: rFS(16))),
                                itemsTextStyle: TextStyle(fontSize: rFS(14)),
                                selectedItemsTextStyle: TextStyle(fontSize: rFS(14), color: Colors.blue),
                                chipDisplay: MultiSelectChipDisplay(
                                  textStyle: TextStyle(fontSize: rFS(12), color: Colors.white),
                                  chipColor: Colors.blue.shade300,
                                  icon: Icon(Icons.close, color: Colors.white, size: rSP(14)),
                                ),
                                validator: (values) {
                                  if (values == null || values.isEmpty) {
                                    return 'Please select at least one category';
                                  }
                                  return null;
                                },
                                onConfirm: (results) {
                                  setState(() {
                                    selectedCategories = results;
                                  });
                                },
                              ),
                              SizedBox(height: rSP(16)),
                              Container(
                                width: double.infinity,
                                padding: EdgeInsets.symmetric(vertical: rSP(12), horizontal: rSP(16)),
                                decoration: BoxDecoration(
                                  border: Border.all(color: Colors.grey.shade300),
                                  borderRadius: BorderRadius.circular(rSP(12)),
                                  color: Colors.grey.shade50,
                                ),
                                child: Row(
                                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                  children: [
                                    Row(
                                      children: [
                                        Icon(Icons.calendar_today, color: Colors.grey.shade600, size: rSP(20)),
                                        SizedBox(width: rSP(12)),
                                        Text('Date: ${DateFormat('MMM dd, yyyy').format(selectedDate)}',
                                          style: TextStyle(fontSize: rFS(16))),
                                      ],
                                    ),
                                    TextButton(
                                      onPressed: () async {
                                        final date = await showDatePicker(
                                          context: context,
                                          initialDate: selectedDate,
                                          firstDate: DateTime(2020),
                                          lastDate: DateTime.now(),
                                        );
                                        if (date != null) {
                                          setState(() {
                                            selectedDate = date;
                                          });
                                        }
                                      },
                                      child: Text('Change', style: TextStyle(fontSize: rFS(14))),
                                    ),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                      SizedBox(height: rSP(20)),
                      Row(
                        children: [
                          Expanded(
                            child: TextButton(
                              onPressed: () => Navigator.pop(context),
                              child: Text('Cancel', style: TextStyle(fontSize: rFS(16))),
                              style: TextButton.styleFrom(
                                padding: EdgeInsets.all(rSP(16)),
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(12))),
                              ),
                            ),
                          ),
                          SizedBox(width: rSP(12)),
                          Expanded(
                            flex: 2,
                            child: ElevatedButton(
                              onPressed: () async {
                                if (_formKey.currentState!.validate()) {
                                  final expense = Expense(
                                    title: titleController.text.trim(),
                                    description: descriptionController.text.trim(),
                                    amount: double.parse(amountController.text),
                                    categories: selectedCategories,
                                    date: selectedDate,
                                  );
                                  
                                  await _databaseHelper.insertExpense(expense);
                                  await _loadExpensesFromDb(); // Reload to reflect new expense
                                  Navigator.pop(context);
                                  
                                  ScaffoldMessenger.of(this.context).showSnackBar(
                                    SnackBar(
                                      content: Text('Expense added successfully!', style: TextStyle(fontSize: rFS(14))),
                                      backgroundColor: Colors.green,
                                      behavior: SnackBarBehavior.floating,
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(8))),
                                    ),
                                  );
                                }
                              },
                              child: Text('Add Expense', style: TextStyle(color: Colors.white, fontSize: rFS(16))),
                              style: ElevatedButton.styleFrom(
                                backgroundColor: Colors.blue.shade600,
                                padding: EdgeInsets.all(rSP(16)),
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(12))),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }

  Future<void> _deleteExpense(int id, BuildContext context) async {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Row(
            children: [
              Icon(Icons.warning, color: Colors.orange, size: rSP(24)),
              SizedBox(width: rSP(8)),
              Text('Delete Expense', style: TextStyle(fontSize: rFS(18))),
            ],
          ),
          content: Text('Are you sure you want to delete this expense? This action cannot be undone.', style: TextStyle(fontSize: rFS(14))),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(12))),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text('Cancel', style: TextStyle(fontSize: rFS(14))),
            ),
            ElevatedButton(
              onPressed: () async {
                await _databaseHelper.deleteExpense(id);
                await _loadExpensesFromDb(); // Reload to reflect deletion
                Navigator.pop(context);
                ScaffoldMessenger.of(this.context).showSnackBar(
                  SnackBar(
                    content: Text('Expense deleted successfully!', style: TextStyle(fontSize: rFS(14))),
                    backgroundColor: Colors.red,
                    behavior: SnackBarBehavior.floating,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(8))),
                  ),
                );
              },
              child: Text('Delete', style: TextStyle(color: Colors.white, fontSize: rFS(14))),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(rSP(8))),
              ),
            ),
          ],
        );
      },
    );
  }
   Future<void> _syncAndLoadAllData() async {
    // Sync data from Firestore to local SQLite first.
    // This is crucial for the reinstall scenario or if data was modified elsewhere.
    // _insertDefaultCategories (called during DB init) handles default items.
    // These sync methods will pull user-generated data and align defaults.
    await _databaseHelper.syncCategoriesFromFirestore();
    await _databaseHelper.syncExpensesFromFirestore();

    // Now load data from the local SQLite database for the UI.
    await _loadCategoriesFromDb();
    await _loadExpensesFromDb();
  }
}